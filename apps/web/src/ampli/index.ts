/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * Ampli - A strong typed wrapper for your Analytics
 *
 * This file is generated by Amplitude. To update run 'ampli pull empires'
 *
 * Required dependencies: @amplitude/analytics-browser@^1.3.0 Tracking Plan Version: 1 Build: 1.0.0 Runtime:
 * browser:typescript-ampli-v2
 *
 * [View Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest)
 *
 * [Full Setup Instructions](https://data.amplitude.com/primodium/primodium-testnet2/implementation/empires)
 */

import * as amplitude from "@amplitude/analytics-browser";

export type Environment = "prod" | "dev";

export const ApiKey: Record<Environment, string> = {
  prod: "",
  dev: "",
};

/** Default Amplitude configuration options. Contains tracking plan information. */
export const DefaultConfiguration: BrowserOptions = {
  plan: {
    version: "1",
    branch: "main",
    source: "empires",
    versionId: "8f0c2168-550a-4531-bc6b-f48fc69bf49e",
  },
  ...{
    ingestionMetadata: {
      sourceName: "browser-typescript-ampli",
      sourceVersion: "2.0.0",
    },
  },
};

export interface LoadOptionsBase {
  disabled?: boolean;
}

export type LoadOptionsWithEnvironment = LoadOptionsBase & {
  environment: Environment;
  client?: { configuration?: BrowserOptions };
};
export type LoadOptionsWithApiKey = LoadOptionsBase & { client: { apiKey: string; configuration?: BrowserOptions } };
export type LoadOptionsWithClientInstance = LoadOptionsBase & { client: { instance: BrowserClient } };

export type LoadOptions = LoadOptionsWithEnvironment | LoadOptionsWithApiKey | LoadOptionsWithClientInstance;

export interface EmpiresAirdropGoldProperties {
  empires?: {
    /** Empire name derived from `empire`, an `EntityId`, with `EmpireEnumToConfig[empire as EEmpire].name`. */
    empireName?: string;
    /** Count of overrides, e.g. for ships. */
    overrideCount?: number;
    /** Amount of gold airdropped in Empires, measured in `wei`. */
    pointsReceived?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresBoostChargeProperties {
  empires?: {
    /** Count of boosting charges for a planet. */
    chargeCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresChargeShieldProperties {
  empires?: {
    /** Count of overrides, e.g. for ships. */
    overrideCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresCreateShipProperties {
  empires?: {
    /** Count of overrides, e.g. for ships. */
    overrideCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresDetonateShieldEaterProperties {
  empires?: {
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresDrainShieldProperties {
  empires?: {
    /** Count of overrides, e.g. for ships. */
    overrideCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresKillShipProperties {
  empires?: {
    /** Count of overrides, e.g. for ships. */
    overrideCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresPlaceMagnetProperties {
  empires?: {
    /** Empire name derived from `empire`, an `EntityId`, with `EmpireEnumToConfig[empire as EEmpire].name`. */
    empireName?: string;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
    /** Turn count of an Empires round. */
    turnCount?: number;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresSellPointsProperties {
  empires?: {
    /** Empire name derived from `empire`, an `EntityId`, with `EmpireEnumToConfig[empire as EEmpire].name`. */
    empireName?: string;
    /** `amount` of Ethereum, measured in `wei`. */
    ethAmount?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresStunChargeProperties {
  empires?: {
    /** Count of boosting charges for a planet. */
    chargeCount?: number;
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export interface EmpiresTacticalStrikeProperties {
  empires?: {
    /** Planet name derived from `planetId`, an `EntityId`, with the `getPlanetName` function. */
    planetName?: string;
  };
  /**
   * The address this transaction is from. On Amplitude, this is also tracked as the user's unique account address
   * initilized with `ampli.from()`.
   */
  transactionFrom?: string;
  /**
   * The amount of gas actually used by this transaction.
   *
   * | Rule | Value   |
   * | ---- | ------- |
   * | Type | integer |
   */
  transactionGasUsed?: number;
  /** The hash of the transaction. */
  transactionHash?: string;
  /**
   * The status of a transaction is 1 is successful or 0 if it was reverted. Direcrly read from `receipt.status`, as
   * described in the ethers.js docs (https://docs.ethers.org/v5/api/providers/types/).
   *
   * | Rule      | Value   |
   * | --------- | ------- |
   * | Type      | integer |
   * | Min Value | 0       |
   * | Max Value | 1       |
   */
  transactionStatus?: number;
  /**
   * The address this transaction is to. This is `null` if the transaction was an init transaction, used to deploy a
   * contract.
   *
   * Since a user will only execute actions on a contract from the frontend, this value will never be null.
   */
  transactionTo?: string;
  /**
   * If the transaction is recorded on-chain and returns a valid receipt with a transaction hash, whether the
   * transaction reverted or not, `transactionValid` will return `true`. Otherwise, it will return `false`.
   *
   * Note that if `transactionValid` is `true`, `transactionStatus` should be checked if a transaction is successful
   * (status 1) or not (status 0).
   */
  transactionValid: boolean;
}

export class EmpiresAirdropGold implements BaseEvent {
  event_type = "empires.airdropGold";

  constructor(public event_properties: EmpiresAirdropGoldProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresBoostCharge implements BaseEvent {
  event_type = "empires.boostCharge";

  constructor(public event_properties: EmpiresBoostChargeProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresChargeShield implements BaseEvent {
  event_type = "empires.chargeShield";

  constructor(public event_properties: EmpiresChargeShieldProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresCreateShip implements BaseEvent {
  event_type = "empires.createShip";

  constructor(public event_properties: EmpiresCreateShipProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresDetonateShieldEater implements BaseEvent {
  event_type = "empires.detonateShieldEater";

  constructor(public event_properties: EmpiresDetonateShieldEaterProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresDrainShield implements BaseEvent {
  event_type = "empires.drainShield";

  constructor(public event_properties: EmpiresDrainShieldProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresKillShip implements BaseEvent {
  event_type = "empires.killShip";

  constructor(public event_properties: EmpiresKillShipProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresPlaceMagnet implements BaseEvent {
  event_type = "empires.placeMagnet";

  constructor(public event_properties: EmpiresPlaceMagnetProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresSellPoints implements BaseEvent {
  event_type = "empires.sellPoints";

  constructor(public event_properties: EmpiresSellPointsProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresStunCharge implements BaseEvent {
  event_type = "empires.stunCharge";

  constructor(public event_properties: EmpiresStunChargeProperties) {
    this.event_properties = event_properties;
  }
}

export class EmpiresTacticalStrike implements BaseEvent {
  event_type = "empires.tacticalStrike";

  constructor(public event_properties: EmpiresTacticalStrikeProperties) {
    this.event_properties = event_properties;
  }
}

export type PromiseResult<T> = { promise: Promise<T | void> };

const getVoidPromiseResult = () => ({ promise: Promise.resolve() });

// prettier-ignore
export class Ampli {
  private disabled: boolean = false;
  private amplitude?: BrowserClient;

  get client(): BrowserClient {
    this.isInitializedAndEnabled();
    return this.amplitude!;
  }

  get isLoaded(): boolean {
    return this.amplitude != null;
  }

  private isInitializedAndEnabled(): boolean {
    if (!this.amplitude) {
      console.error('ERROR: Ampli is not yet initialized. Have you called ampli.load() on app start?');
      return false;
    }
    return !this.disabled;
  }

  /**
   * Initialize the Ampli SDK. Call once when your application starts.
   *
   * @param options Configuration options to initialize the Ampli SDK with.
   */
  load(options: LoadOptions): PromiseResult<void> {
    this.disabled = options.disabled ?? false;

    if (this.amplitude) {
      console.warn('WARNING: Ampli is already intialized. Ampli.load() should be called once at application startup.');
      return getVoidPromiseResult();
    }

    let apiKey: string | null = null;
    if (options.client && 'apiKey' in options.client) {
      apiKey = options.client.apiKey;
    } else if ('environment' in options) {
      apiKey = ApiKey[options.environment];
    }

    if (options.client && 'instance' in options.client) {
      this.amplitude = options.client.instance;
    } else if (apiKey) {
      this.amplitude = amplitude.createInstance();
      const configuration = (options.client && 'configuration' in options.client) ? options.client.configuration : {};
      return this.amplitude.init(apiKey, undefined, { ...DefaultConfiguration, ...configuration });
    } else {
      console.error("ERROR: ampli.load() requires 'environment', 'client.apiKey', or 'client.instance'");
    }

    return getVoidPromiseResult();
  }

  /**
   * Identify a user and set user properties.
   *
   * @param userId The user's id.
   * @param options Optional event options.
   */
  identify(
    userId: string | undefined,
    options?: EventOptions,
  ): PromiseResult<Result> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    if (userId) {
      options = {...options,  user_id: userId};
    }

    const amplitudeIdentify = new amplitude.Identify();
    return this.amplitude!.identify(
      amplitudeIdentify,
      options,
    );
  }

 /**
  * Flush the event.
  */
  flush() : PromiseResult<Result> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    return this.amplitude!.flush();
  }

  /**
   * Track event
   *
   * @param event The event to track.
   * @param options Optional event options.
   */
  track(event: Event, options?: EventOptions): PromiseResult<Result> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    return this.amplitude!.track(event, undefined, options);
  }

  /**
   * empires.airdropGold
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.airdropGold)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresAirdropGold(
    properties: EmpiresAirdropGoldProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresAirdropGold(properties), options);
  }

  /**
   * empires.boostCharge
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.boostCharge)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresBoostCharge(
    properties: EmpiresBoostChargeProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresBoostCharge(properties), options);
  }

  /**
   * empires.chargeShield
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.chargeShield)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresChargeShield(
    properties: EmpiresChargeShieldProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresChargeShield(properties), options);
  }

  /**
   * empires.createShip
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.createShip)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresCreateShip(
    properties: EmpiresCreateShipProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresCreateShip(properties), options);
  }

  /**
   * empires.detonateShieldEater
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.detonateShieldEater)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresDetonateShieldEater(
    properties: EmpiresDetonateShieldEaterProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresDetonateShieldEater(properties), options);
  }

  /**
   * empires.drainShield
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.drainShield)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresDrainShield(
    properties: EmpiresDrainShieldProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresDrainShield(properties), options);
  }

  /**
   * empires.killShip
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.killShip)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresKillShip(
    properties: EmpiresKillShipProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresKillShip(properties), options);
  }

  /**
   * empires.placeMagnet
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.placeMagnet)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresPlaceMagnet(
    properties: EmpiresPlaceMagnetProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresPlaceMagnet(properties), options);
  }

  /**
   * empires.sellPoints
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.sellPoints)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresSellPoints(
    properties: EmpiresSellPointsProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresSellPoints(properties), options);
  }

  /**
   * empires.stunCharge
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.stunCharge)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresStunCharge(
    properties: EmpiresStunChargeProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresStunCharge(properties), options);
  }

  /**
   * empires.tacticalStrike
   *
   * [View in Tracking Plan](https://data.amplitude.com/primodium/primodium-testnet2/events/main/latest/empires.tacticalStrike)
   *
   * Event has no description in tracking plan.
   *
   * @param properties The event's properties (e.g. empires)
   * @param options Amplitude event options.
   */
  empiresTacticalStrike(
    properties: EmpiresTacticalStrikeProperties,
    options?: EventOptions,
  ) {
    return this.track(new EmpiresTacticalStrike(properties), options);
  }
}

export const ampli = new Ampli();

// BASE TYPES
type BrowserOptions = amplitude.Types.BrowserOptions;

export type BrowserClient = amplitude.Types.BrowserClient;
export type BaseEvent = amplitude.Types.BaseEvent;
export type IdentifyEvent = amplitude.Types.IdentifyEvent;
export type GroupEvent = amplitude.Types.GroupIdentifyEvent;
export type Event = amplitude.Types.Event;
export type EventOptions = amplitude.Types.EventOptions;
export type Result = amplitude.Types.Result;
